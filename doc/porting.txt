
		TOPPERS/HRP3カーネル
		ターゲット依存部 ポーティングガイド

		対応バージョン: Release 3.1.0
		最終更新: 2019年3月13日

このドキュメントは，TOPPERS/HRP3カーネルを，未サポートのターゲットシス
テムにポーティングするために必要となるターゲット依存部の実装方法を説明
するものである．

----------------------------------------------------------------------
 TOPPERS/HRP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     High Reliable system Profile Kernel

 Copyright (C) 2016-2019 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: porting.txt 689 2019-03-20 06:39:35Z ertl-hiro $
----------------------------------------------------------------------

○目次

０．本ドキュメントの位置づけ
１．共通事項
２．システム構築環境のターゲット依存部
	2.1 コンフィギュレーション処理の流れ
	2.2 リンク方法の設定
	2.3 依存関係の定義（オプション）
３．TOPPERS共通定義のターゲット依存部
４．システムインタフェースレイヤ（SIL）のターゲット依存部
５．カーネルAPIのターゲット依存部
	5.1 ターゲット定義でサポートする機能
	5.2 ソフトウェア割込みによるサービスコール呼出し
		5.2.1 一般のサービスコール
		5.2.2 cal_svc
	5.3 ターゲット依存のメモリオブジェクト属性
	5.4 時間パーティショニング機能のための定義
６．カーネル実装のターゲット依存部
	6.1 カーネル実装のターゲット依存部の共通事項
	6.2 メモリ保護設定と保護ドメインの管理
	6.3 タスクのスタック領域
		6.3.1 ユーザタスクの用いるスタック領域
		6.3.2 レッドゾーン保護とダミースタック
	6.4 タスクディスパッチャ
		6.4.1 ディスパッチャ本体
		6.4.2 自発的なディスパッチ
		6.4.3 ディスパッチャの動作開始
		6.4.4 タスクの起動準備と実行開始
	6.5 割込みハンドラの出入口処理
	6.6 CPU例外ハンドラの出入口処理
	6.7 ソフトウェア割込みによるサービスコールの出入口処理
	6.8 システム周期オーバラン例外
	6.9 スタートアップモジュール
	6.10 カーネル実装に関するその他の定義
		6.10.1 ターゲット依存のオブジェクト属性
		6.10.2 メモリ管理に関する処理の変更
		6.10.3 エラーチェック方法の指定
	6.11 タイムウィンドウタイマドライバ
		6.11.1 タイムウィンドウタイマドライバのファイル構成
		6.11.2 タイムウィンドウタイマの操作と割込み処理
	6.12 カーネル実装のコンフィギュレーションファイル
７．コンフィギュレータ設定ファイルのターゲット依存部
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2の生成スクリプトのターゲット依存部
		7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数
		7.2.2 ターゲット非依存部で定義される変数と関数
		7.2.3 リンカスクリプトの生成スクリプトをインクルードする前に定義
			  すべき変数と関数
	7.3 パス3の生成スクリプトのターゲット依存部（自動メモリ配置用，オプション）
	7.4 パス4の生成スクリプトのターゲット依存部（自動メモリ配置用）
		7.4.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数
		7.4.2 ターゲット非依存部で定義される変数と関数
	7.5 チェックパスの生成スクリプトのターゲット依存部
		7.5.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数
		7.5.2 ターゲット依存部で行うべきエラーチェック
	7.6 cfg1_out.cのリンクに必要なスタブの定義ファイル
８．システムサービス等のターゲット依存部
	8.1 ターゲット依存部のコンポーネント記述ファイル
	8.2 サンプルプログラムとテストプログラムのターゲット依存定義
９．その他
	9.1 その他に修正が必要な箇所
	9.2 ドキュメント


０．本ドキュメントの位置づけ

TOPPERS/HRP3カーネルは，TOPPERS/ASP3カーネル（以下，ASP3カーネル）を拡
張する形で開発したものである．そのため，HRP3カーネルを未サポートのター
ゲットシステムにポーティングする場合には，まずASP3カーネルをポーティン
グすることを推奨する．

現時点では，このドキュメントは未完成である．HRP3カーネルのポーティング
を行う場合には，このドキュメントに加えて，「TOPPERS/HRP3カーネル 設計
メモ」を参照する必要がある．また，ターゲット依存部と非依存部の切り分け
が確立できているわけではない．ターゲット依存部の修正が必要な場合には，
開発者に相談いただけると幸いである．


１．共通事項

ASP3カーネルのポーティングにあたっての共通事項は，HRP3カーネルのポーティ
ングにも適用される．以下では，ASP3カーネルと異なる点についてのみ説明す
る．

1.1 自動メモリ配置と手動メモリ配置

HRP3カーネルでは，デフォルトでは自動メモリ配置を行い，手動メモリ配置を
ターゲット依存にサポートするものとしている．しかし，自動メモリ配置の方
がポーティングの難易度が高いため，ユーザが自動メモリ配置を使用しない場
合には，ターゲット依存部は手動メモリ配置のみをサポートすることとしても
良い．


２．システム構築環境のターゲット依存部

HRP3カーネルのシステム構築環境のターゲット依存部は，ASP3カーネルとほぼ
同様である．以下では，ASP3カーネルと異なる点についてのみ説明する．

HRP3カーネルでは，サンプルのMakefileとして，自動メモリ配置用
（sample/Makefile）と手動メモリ配置用（sample/Makefile_mml）の2つを別々
に用意している．条件文を用いて2つを統合することも可能であるが，手動メ
モリ配置用のMakefileを不必要に複雑にしないために，別々に用意している．

2.1 コンフィギュレーション処理の流れ

(2-1-1) USE_CFG_PASS3

自動メモリ配置の場合に，コンフィギュレータのパス3を用いるかどうかは，
ターゲット依存である．パス3を用いる場合には，Makefileのターゲット依存
部でUSE_CFG_PASS3を"true"に定義する．

2.2 リンク方法の設定

(2-2-1) LDSCRIPT				リンカスクリプトのファイル名

最終的なロードモジュールをリンクするためのリンカスクリプトのファイル名
を，標準（ldscript.ld）から変更したい場合に，この変数に定義する．なお，
リンカスクリプトは，自動メモリ配置の場合はコンフィギュレータが生成し，
手動メモリ配置の場合はユーザが作成する．

(2-2-1) CFG1_OUT_LDSCRIPT		パス1のためのリンカスクリプトのファイル名

パス1のロードモジュールをリンクするために，開発環境に標準のリンカスク
リプトが使用できない場合には，ターゲット依存部でリンカスクリプトを用意
し，そのファイル名をこの変数に定義する．

(2-2-3) CFG2_OUT_LDSCRIPT		パス2のためのリンカスクリプトのファイル名
(2-2-4) CFG3_OUT_LDSCRIPT		パス3のためのリンカスクリプトのファイル名

自動メモリ配置の場合に，パス2およびパス3のロードモジュールをリンクする
ためのリンカスクリプトのファイル名を，標準（それぞれ，cfg2_out.ld，
cfg3_out.ld）から変更したい場合に，これらの変数に定義する．

(2-2-5) TEXT_START_ADDRESS		テキストセクションの先頭番地
(2-2-6) DATA_START_ADDRESS		データセクションの先頭番地

ASP3カーネルで使用していたこれらの変数は，HRP3カーネルでは使用しない．

2.3 依存関係の定義（オプション）

自動メモリ配置の場合には，コンフィギュレータのパスが増えているため，依
存関係を記述すべきタイムスタンプファイルに，kernel_opt.timestamp（パス
3を用いる場合のみ）とkernel_mem.timestampが追加されている．一方，チェッ
クパスは生成スクリプトを用いないため，check.timestampが依存するターゲッ
ト依存部のファイルはない．

その結果，ターゲット依存部ディレクトリのMakefile.targetに含める典型的
な記述は，以下のようになる（開発環境依存部／プロセッサコア依存部／チッ
プ依存部にファイルを分割している場合には，これに追加する必要がある）．

----------------------------------------
cfg1_out.timestamp: $(TARGETDIR)/target_sym.def
offset.timestamp: $(TARGETDIR)/target_offset.trb
kernel_cfg.timestamp: $(TARGETDIR)/target_kernel.trb
kernel_opt.timestamp: $(TARGETDIR)/target_opt.trb
kernel_mem.timestamp: $(TARGETDIR)/target_mem.trb
----------------------------------------

なお，手動メモリ配置の場合は，ASP3カーネルと同様である．


３．TOPPERS共通定義のターゲット依存部

TOPPERS共通定義のターゲット依存部は，ASP3カーネルとHRP3カーネルで共通
である．


４．システムインタフェースレイヤ（SIL）のターゲット依存部

システムインタフェースレイヤ（SIL）のターゲット依存部は，ASP3カーネル
とHRP3カーネルで共通である．


５．カーネルAPIのターゲット依存部

HRP3カーネルのカーネルAPIのターゲット依存部は，ASP3カーネルのものに対
して，以下の追加を行っている．以下では，ASP3カーネルと異なる点について
のみ説明する．

5.1 ターゲット定義でサポートする機能

ターゲット定義でサポートする機能を表すマクロに，以下の4つが追加になっ
ている．

(5-1-1) TOPPERS_TARGET_SUPPORT_ML_AUTO		自動メモリ配置をサポートする
(5-1-2) TOPPERS_TARGET_SUPPORT_ML_MANUAL	手動メモリ配置をサポートする

ATT_MOD，ATT_PMAをサポートする場合に，それぞれのシンボルをマクロ定義す
る．

(5-1-3) TOPPERS_TARGET_SUPPORT_ATT_MOD		ATT_MODをサポートする
(5-1-4) TOPPERS_TARGET_SUPPORT_ATT_PMA		ATT_PMAをサポートする

ATT_MOD，ATT_PMAをサポートする場合に，それぞれのシンボルをマクロ定義す
る．

5.2 ソフトウェア割込みによるサービスコール呼出し

カーネルの各サービスコールを，ソフトウェア割込みによって呼び出すための
関数の定義を，target_svc.h（または，そこからインクルードされるファイル）
に含める．

5.2.1 一般のサービスコール

cal_svc以外のサービスコールについては，TOPPERS_SVC_CALLがマクロ定義さ
れていない場合のみ，サービスコールをソフトウェア割込みによって呼び出す
ための関数を，インライン関数の形で定義する．

まず，ターゲットプロセッサにおいて，サービスコールをソフトウェア割込み
によって呼び出すための方法を定める必要がある．具体的には，用いるソフト
ウェア割込み命令や，機能番号とパラメータの渡し方を定める．次に，用いる
開発環境において，機能番号とパラメータを設定した上で，ソフトウェア割込
み命令を発行する記述を調査する必要がある．

GNU開発環境においては，インラインアセンブラの機能を用いてこれを実現す
る方法が有力である．そこで，GNU開発環境向けに，n個のパラメータを持つサー
ビスコールを呼び出すインラインアセンブラ記述をCAL_SVC_nMという名称のマ
クロに定義しておけば，各サービスコールを呼び出す関数を定義してくれる記
述を，arch/gcc/tool_svc.hに用意している．

arch/gcc/tool_svc.hを用いるには，ターゲット依存部でCAL_SVC_nMマクロを
定義した上で，TOPPERS_SVC_CALLがマクロ定義されていない場合に，このファ
イルをインクルードする．これにより，TOPPERS_SVC_CALLがマクロ定義されて
いない場合に，カーネルの各サービスコールをソフトウェア割込みによって呼
び出すための関数の定義を行うことができる．

ターゲット依存部で定義すべきCAL_SVC_nMマクロの仕様は次の通り．

(5-2-1-1) CAL_SVC_nM(TYPE, FNCD, TYPE1, PAR1, ..., TYPEn, PARn)
    ※ nは0〜5のいずれか．

サービスコールの返り値の型をTYPE，機能番号をFNCD，n個のパラメータの型
と名前をそれぞれTYPE1〜TYPEn，PAR1〜PARnに渡された時に，そのサービスコー
ルをソフトウェア割込みによって呼び出すインラインアセンブラ記述に展開す
るマクロ．

(5-2-1-2) CAL_SVC_1M_SYSTIM(TYPE, FNCD, TYPE1, PAR1)

サービスコールの返り値の型をTYPE，機能番号をFNCD，パラメータが1つで，
その型がSYSTIMで，その名前をPAR1に渡された時に，そのサービスコールをソ
フトウェア割込みによって呼び出すインラインアセンブラ記述に展開するマク
ロ．TYPE1には，SYSTIMが渡される．

SYSTIMは64ビットの整数型（ただし，64ビットの整数型がサポートされないター
ゲットでは，32ビットの整数型）であるため，CAL_SVC_1Mとは別のマクロとし
ている．

なお，arch/gcc/tool_svc.hは，gensvc.rbユーティリティを用いて生成してい
る．他の開発環境向けに，これと同等のファイルを準備したい場合には，
gensvc.rbを拡張するのが良い．

5.2.2 cal_svc

cal_svcは，TOPPERS_SVC_CALLのマクロ定義の有無に関わらず，ソフトウェア
割込みにより拡張サービスコールを呼び出すためのAPIである．cal_svcは，
target_svc.h（または，そこからインクルードされるファイル）において，イ
ンライン関数の形で定義する．cal_svcの実装には，上述のCAL_SVC_5Mを用い
ることができる．

5.3 ターゲット依存のメモリオブジェクト属性

ターゲット依存のメモリオブジェクト属性がある場合には，カーネルAPIのター
ゲット依存部で定義する．

5.4 時間パーティショニング機能のための定義

(5-4-1) TMAX_TWDTIM（オプション，デフォルトはUINT32_MAX）

プロセッサ時間としてタイムウィンドウタイマに設定できる最大値（単位はマ
イクロ秒）にマクロ定義する．


６．カーネル実装のターゲット依存部

HRP3カーネルのカーネル実装のターゲット依存部は，ASP3カーネルのものに対
して，以下の追加を行っている．以下では，ASP3カーネルと異なる点について
のみ説明する．

6.1 カーネル実装のターゲット依存部の共通事項

コンフィギュレータの設定ファイルのターゲット依存部に，
target_opt.trb（パス3を用いる場合のみ）とtarget_mem.trbが追加になって
いる．いずれも自動メモリ配置の場合に必要となるものである．

6.2 メモリ保護設定と保護ドメインの管理

HRP3カーネルにおいては，メモリ配置とメモリ保護の設定は静的に決定される
ため，それらの処理のほとんどはコンフィギュレータによって行う．

カーネル実装においては，基本的には，タスク切換えの際に，メモリ保護設定
を切り換えるだけでよい．具体的には，タスク切換えに伴い保護ドメインを切
り換える場合に，メモリ保護設定を切り換える必要がある．また，タスクのユー
ザスタック領域のメモリ保護設定を切り換える必要がある．

多くのターゲットプロセッサにおいて，ある保護ドメインを実行中のメモリ保
護設定のための情報を，保護ドメイン初期化ブロック（DOMINIB）中に保持す
る必要がある．具体的には，メモリ管理ユニット（MMU）を持つプロセッサで
は用いるページテーブルなどの情報，メモリ保護ユニット（MPU）を持つプロ
セッサではその保護ドメインにおけるMPUの設定内容などがこれに該当する．

(6-2-1) USE_DOMINICTXB（オプション）
(6-2-2) DOMINICTXB（オプション）

ターゲット依存の情報をDOMINIBに入れたい場合には，USE_DOMINICTXBをマク
ロ定義し，DOMINIB中に持つことが必要なデータ構造の型を，DOMINICTXBに定
義する．

(6-2-3) USE_LATERPASS_DOMINIB

自動メモリ配置において，DOMINICTXBの初期値をパス2で決めることができな
い場合には，USE_LATERPASS_DOMINIBをマクロ定義することで，パス2では仮の
DOMINIBを（kernel_cfg.cではなく）kernel_mem2.cに生成し，最終的な
DOMINIBの生成をパス4で行うことができる．

6.3 タスクのスタック領域

6.3.1 ユーザタスクの用いるスタック領域

ユーザタスクは，システムスタック領域とユーザスタック領域の2つのスタッ
ク領域を使用する．そのため，タスク初期化ブロック中には，これらの2つの
スタック領域のサイズと先頭番地を保持する．

USE_TSKINICTXBをマクロ定義しない場合には，タスク初期化ブロック中に，
ASP3カーネルの場合のstkszとstkに変えて，システムスタック領域用のsstksz
とsstk，ユーザスタック領域用のustkszとustkの各フィールドを持つ．なお，
システムスタックに対しては，sstkszとsstkを用い，ustkszとustkは用いない．

USE_TSKINICTXBをマクロ定義してTSKINICTXBをターゲット依存部で定義する場
合にも，ASP3カーネルのターゲット依存部に対して，同様の修正が必要である．

(6-3-1-1) DEFAULT_SSTKSZ

CRE_TSKにより，システムスタック領域を指定せずにユーザタスクを生成した
場合のデフォルトのシステムスタック領域のサイズ．

6.3.2 ユーザスタック領域の扱い

MMUを持つターゲットプロセッサでは，タスク毎にユーザスタック領域のアク
セス権を切り換えると，効率が極めて低下する場合が多い．その場合には，タ
スク毎にアクセス権を切り換えるのをやめ，タスクのユーザスタック領域を，
そのタスクが属する保護ドメイン全体からアクセスできるものとする．

(6-3-2-1) OMIT_USTACK_PROTECT（オプション）

タスクのユーザスタック領域を，そのタスクが属する保護ドメイン全体からア
クセスできる（言い換えると，ユーザスタック領域をタスク毎に保護しない）
ものとする場合には，OMIT_USTACK_PROTECTをマクロ定義する．

(6-3-2-2) CHECK_TARGET_USTACK(ustksz, ustk, p_dominib)（オプション）

acre_tskによりユーザドメインに属するタスクを生成する場合に，ustkと
ustkszで指定されるスタック領域が，p_dominibで指定されるユーザドメイン
に属するタスクのユーザスタック領域として適切かを判定するためのチェック
マクロ．動的生成機能拡張パッケージを使用する場合で，以下に示すデフォル
トの定義を変更したい場合に，定義する必要がある．

----------------------------------------
#define CHECK_TARGET_USTACK(ustksz, ustk, p_dominib) do {			\
	CHECK_PAR(USTKSZ_ALIGN(ustksz));			/*［NGKI1056］*/	\
	CHECK_PAR(USTACK_ALIGN(ustk));				/*［NGKI1056］*/	\
	CHECK_OBJ(valid_ustack(ustk, ustksz));		/*［NGKI1060］*/	\
} while (false)
----------------------------------------

6.3.3 レッドゾーン保護とダミースタック

タスクのユーザスタック領域を，そのタスクが属する保護ドメイン全体からア
クセスできるものとした場合には，他のタスクからの不正アクセスのリスクを
下げるために，レッドゾーン方式のユーザスタック領域保護を用いるのが望ま
しい．

(6-3-3-1) USE_REDZONE（オプション）

レッドゾーン方式を用いる場合には，USE_REDZONEをマクロ定義する．

(6-3-3-2) TARGET_DUMMY_STKSZ（オプション）

レッドゾーン方式において用いるダミースタック領域をサイズを，
TARGET_DUMMY_STKSZに定義する．

6.4 タスクディスパッチャ

6.4.1 ディスパッチャ本体

ディスパッチャ本体（dispatcher）の処理内容は次の通り．

----------------------------------------
void
dispatcher(void)
{
	DOMINIB	*p_dominib;

#ifdef LOG_DSP_ENTER
	log_dsp_enter(p_runtsk);
#endif /* LOG_DSP_ENTER */
	if (自タスクがユーザタスク) {
		自タスクのユーザスタック領域をアクセスできない状態とする
	}

  dispatcher_0:
	p_runtsk = p_schedtsk;
	if (p_runtsk != NULL) {
		自タスク（p_runtsk）のTCBからスタックポインタを復帰する
		if (自タスクがユーザタスク) {
			p_dominib = p_runtsk->p_dominib;
			if (p_ctxdom != p_dominib) {
				p_ctxdom = p_dominib;
				p_dominibに関するアクセス保護情報をMMU/MPUに設定する
			}
			自タスクのユーザスタック領域をアクセスできる状態とする
		}
#ifdef LOG_DSP_LEAVE
		log_dsp_leave(p_runtsk);
#endif /* LOG_DSP_LEAVE */
		自タスクのTCBから実行再開番地を復帰し，そこへ分岐する … (*a)
	}

	/*
	 *  アイドル処理
	 */
	if (twdtimer_enable) {
		twdtimer_start();				/* タイムウィンドウタイマの動作開始 */
	}
	割込みを許可したらCPUロック解除状態になるよう準備する
	割込みをすべて許可する
	while (true) {
		割込み発生を待つ … (*b)
	}
}
----------------------------------------

6.4.2 自発的なディスパッチ

(6-4-2-1) void dispatch(void)

タスクからの自発的なディスパッチ処理（dispatch）の処理内容は次の通り．

----------------------------------------
void
dispatch(void)
{
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_stop();					/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	rundomをスタックに保存する
	スクラッチレジスタを除くすべてのレジスタをスタックに保存する
	if (自タスクがユーザタスク) {
		ユーザスタックポインタをスタックに保存する
	}
	スタックポインタを自タスク（p_runtsk）のTCBに保存する
	dispatch_rを，実行再開番地として自タスクのTCBに保存する … (*a)
	dispatcherに分岐する

  dispatch_r:
	if (自タスクがユーザタスク) {
		ユーザスタックポインタをスタックから復帰する
	}
	スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
	rundomをスタックから復帰する
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	if (twdtimer_enable) {
		twdtimer_control();				/* タイムウィンドウタイマの切換え */
	}
}
----------------------------------------

6.4.3 ディスパッチャの動作開始

(6-4-3-1) void start_dispatch(void)

ディスパッチャの動作開始処理（start_dispatch）の処理内容は次の通り．

----------------------------------------
void
start_dispatch(void)
{
	タスクコンテキストに切り換える
	スタックをIDが1のタスクのシステムスタック領域に切り換える
	CPUロック状態・割込み優先度マスク全解除状態にする
	dispatcher_0に分岐する
}
----------------------------------------

6.4.4 タスクの起動準備と実行開始

(6-4-4-1) void activate_context(TCB *p_tcb)

タスクの起動準備処理（activate_context）では，起動するタスクがシステム
タスクであるかユーザタスクであるかによって，異なるタスク開始時処理（シ
ステムタスクの場合はstart_stask_r，ユーザタスクの場合はstart_utask_r）
を，実行再開番地に設定する．

activate_context，start_stark_r，start_utask_rの処理内容は次の通り．

----------------------------------------
void
activate_context(TCB *p_tcb)
{
	指定されたタスク（p_tcb）のTCB中のスタックポインタを初期化する
	if (指定されたタスクがユーザタスク) {
		start_utask_rを，実行再開番地として自タスクのTCBに保存する
	}
	else {
		start_stask_rを，実行再開番地として自タスクのTCBに保存する
	}
	return;

  start_stask_r:
	rundom = TACP_KERNEL;
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	if (twdtimer_enable) {
		twdtimer_stop();				/* タイムウィンドウタイマの停止 */
	}
	CPUロック解除状態にする
	自タスク（p_runtsk）の起動番地を，拡張情報をパラメータとして呼び出す
	ext_tskに分岐する ... (*c)

  start_utask_r:
	rundom = p_runtsk->p_dominib->domptn;
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	if (twdtimer_enable) {
		twdtimer_start();				/* タイムウィンドウタイマの動作開始 */
	}
	自タスクのユーザスタックポインタを初期化する
	例外/割込みからのリターンによって，
			自タスクの起動番地へ分岐するように準備する … (*1)
	例外/割込みからのリターンによって，非特権モード・CPUロック解除状態・
			割込み優先度マスク全解除状態になるように準備する … (*2)
	自タスクの起動番地へ分岐する際に，
			自タスクの拡張情報がパラメータとして渡るように準備する … (*3)
	自タスクの起動番地からのリターンにより，
			call_ext_tskの番地へ分岐するように準備する … (*4)
	例外/割込みからのリターン
}
----------------------------------------

(6-4-4-2) void call_ext_tsk(void)

ユーザタスクがメインルーチンからリターンした場合に呼び出される関数とし
て，以下の内容の関数call_ext_tskを用意する．call_ext_tskは，すべての保
護ドメインから呼び出せる共有ライブラリとしなければならない（よって，
ext_tskとext_kerをソフトウェア割込みを用いて呼び出すコードとする）．

----------------------------------------
void
call_ext_tsk(void)
{
	(void) ext_tsk();
	(void) ext_ker();
	assert(0);
}
----------------------------------------

6.5 割込みハンドラの出入口処理

割込みハンドラの出入口処理の擬似コードは次の通り．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	少なくともカーネル管理の割込みを禁止した状態にする … (*d)
	if (非特権モードで割込み発生) {
		スタックを実行状態のタスクのシステムスタックに切り換える
	}
	スクラッチレジスタをスタックに保存する … (*p)
	if (割込みがタスクコンテキストで発生) {
		if (twdtimer_enable) {
			twdtimer_stop();			/* タイムウィンドウタイマの停止 */
		}
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_stop();				/* オーバランタイマの停止 */ … (*e)
#endif /* TOPPERS_SUPPORT_OVRHDR */
		rundomをスタックに保存する
		rundom = TACP_KERNEL;
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}
	割込み優先度マスクを，受け付けた割込みの割込み優先度に設定する
	割込みハンドラの入口で必要なIRCの操作を行う（割込み要求ラインがエッ
				ジトリガである場合のトリガされた割込み要求のクリアなど）
	CPUロック解除状態にする（受け付けた割込みよりも優先度の高い割込みを
												受け付けるようにする）

#ifdef LOG_INH_ENTER
	log_inh_enter(割込みハンドラ番号);
#endif /* LOG_INH_ENTER */
	割込みハンドラを呼び出す
#ifdef LOG_INH_LEAVE
	log_inh_leave(割込みハンドラ番号);
#endif /* LOG_INH_LEAVE */

	少なくともカーネル管理の割込みを禁止した状態にする
	割込みハンドラの出口で必要なIRCの操作を行う（IRCに対する割込み処理
														の終了通知など）
	割込み優先度マスクを，割込みを受け付ける前の値に戻す … (*f)

	if (割込みがタスクコンテキストで発生) {
		スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
																… (*g)
		if (p_runtsk == NULL) {
			タスクのスタックに保存したスクラッチレジスタ，rundom等を捨てる
																… (*o)
			CPUロック状態にする … (*h)
			割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
			dispatcher_0に分岐する
		}

		if (p_runtsk != p_schedtsk) {
			CPUロック状態にする … (*h)
			割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
			スクラッチレジスタを除くすべてのレジスタをスタックに保存する
			if (自タスクがユーザタスク) {
				ユーザスタックポインタをスタックに保存する
			}
			スタックポインタを自タスク（p_runtsk）のTCBに保存する
			ret_int_rを，実行再開番地として自タスクのTCBに保存する … (*a)
			dispatcherに分岐する

		  ret_int_r:
			if (自タスクがユーザタスク) {
				ユーザスタックポインタをスタックから復帰する
			}
			スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
		}
		rundomをスタックから復帰する
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_start();			/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
		if (twdtimer_enable) {
			twdtimer_control();			/* タイムウィンドウタイマの切換え */
		}
	}
	割込み処理からのリターンにより，CPUロック解除状態に戻るように準備する
	スクラッチレジスタをスタックから復帰する … (*p)
	if (戻り先が非特権モード) {
		スタックを実行状態のタスクのユーザスタックに戻す
	}
	割込み処理からのリターン
}
----------------------------------------

6.6 CPU例外ハンドラの出入口処理

CPU例外ハンドラの出入口処理の擬似コードは次の通り．

----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	if (非特権モードでCPU例外発生) {
		スタックを実行状態のタスクのシステムスタックに切り換える
	}
	スクラッチレジスタをスタックに保存する … (*p)
	CPU例外が発生した状況を判断するための追加情報をスタックに保存する … (*j)
	この時点でのスタックポインタ±nを，CPU例外の情報を記憶している領域の
										先頭番地とする（必要なら保存する）
	if (カーネル管理外のCPU例外) {
		if (CPU例外がタスクコンテキストで発生) {
			rundomをスタックに保存する … (*5)
			rundom = TACP_KERNEL;
			スタックを非タスクコンテキスト用のスタックに切り換え，
									非タスクコンテキストに切り換える … (*k)
		}
		システム状態（コンテキストは除く）を，CPU例外発生時の状態にする
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
		if (CPU例外がタスクコンテキストで発生) {
			スタックをタスク用のスタックに戻し，
									タスクコンテキストに切り換える … (*k)
			rundomをスタックから復帰する … (*5)
		}
		CPU例外処理からのリターン後に，CPU例外発生時のシステム状態に
													戻るように準備する
	}
	else {
		if (CPU例外がタスクコンテキストで発生) {
			少なくともカーネル管理の割込みを禁止した状態にする
			if (twdtimer_enable) {
				twdtimer_stop();		/* タイムウィンドウタイマの停止 */
			}
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_stop();			/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
			rundomをスタックに保存する
			rundom = TACP_KERNEL;
			スタックを非タスクコンテキスト用のスタックに切り換え，
									非タスクコンテキストに切り換える
		}
		割込み優先度マスクを，CPU例外発生時の値に設定する … (*l)
		CPUロック解除状態にする（CPU例外発生時の割込み優先度マスクよりも
							優先度の高い割込みを受け付けるようにする）

#ifdef LOG_EXC_ENTER
		log_exc_enter(CPU例外ハンドラ番号);
#endif /* LOG_EXC_ENTER */
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
#ifdef LOG_EXC_LEAVE
		log_exc_leave(CPU例外ハンドラ番号);
#endif /* LOG_EXC_LEAVE */

		少なくともカーネル管理の割込みを禁止した状態にする … (*m)
		割込み優先度マスクを，CPU例外発生時の値に設定する … (*n)

		if (CPU例外がタスクコンテキストで発生) {
			スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
																	… (*g)
			if (p_runtsk == NULL) {									… (*q)
				タスクのスタックに保存したスクラッチレジスタ，追加
											情報，rundom等を捨てる … (*o)
				CPUロック状態にする … (*h)
				割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
				dispatcher_0に分岐する
			}

			if (p_runtsk != p_schedtsk) {
				CPUロック状態にする … (*h)
				割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
				スクラッチレジスタを除くすべてのレジスタをスタックに保存する
				if (自タスクがユーザタスク) {
					ユーザスタックポインタをスタックに保存する
				}
				スタックポインタを自タスク（p_runtsk）のTCBに保存する
				ret_exc_rを，実行再開番地として自タスクのTCBに保存する … (*a)
				dispatcherに分岐する

			  ret_exc_r:
				if (自タスクがユーザタスク) {
					ユーザスタックポインタをスタックから復帰する
				}
				スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
			}
			rundomをスタックから復帰する
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_start();		/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
			if (twdtimer_enable) {
				twdtimer_control();		/* タイムウィンドウタイマの切換え */
			}
		}
		CPU例外処理からのリターン後に，CPUロック解除状態に戻るように準備する
	}
	CPU例外が発生した状況を判断するための追加情報をスタック上から捨てる
	スクラッチレジスタをスタックから復帰する … (*p)
	if (戻り先が非特権モード) {
		スタックを実行状態のタスクのユーザスタックに戻す
	}
	CPU例外処理からのリターン
}
----------------------------------------

6.7 ソフトウェア割込みによるサービスコールの出入口処理

ソフトウェア割込みによるサービスコールの出入口処理（svc_entry）の処理
内容は次の通り．

----------------------------------------
ER_UINT
svc_entry(パラメータリスト, FN fncd)
{
	ER_UINT		ercd;

	if (非特権モードからの呼び出し) {
		スタックを実行状態のタスクのシステムスタックに切り換える
	}
	if (fncd <= 0) {
		/*
		 *  カーネルのサービスコールの場合
		 */
		if (fncd < TMIN_FNCD) {
			ercd = E_RSFN;
			goto error_exit;
		}
		ソフトウェア割込みによりシステム状態が変化する場合には，
							ソフトウェア割込み前のシステム状態に戻す
		ercd = (*(svc_table[-fncd]))(パラメータリスト);
		ソフトウェア割込みからリターン後のシステム状態が，
							この時点でのシステム状態になるよう準備する
	}
	else {
		/*
		 *  拡張サービスコールの場合
		 */
		const SVCINIB	*p_svcinib;
		ID				cdmid;

		if (fncd > tmax_fncd) {
			ercd = E_RSFN;
			goto error_exit;
		}
		p_svcinib = &svcinib_table[fncd - 1];
		if (p_svcinib->extsvc == NULL) {
			ercd = E_RSFN;
			goto error_exit;
		}

		if (非タスクコンテキストからの呼出し) {
			ソフトウェア割込みによりシステム状態が変化する場合には，
							ソフトウェア割込み前のシステム状態に戻す
			LOG_EXTSVC_ENTER(fncd, パラメータリスト, TDOM_KERNEL);
			ercd = (*(p_svcinib->extsvc))(パラメータリスト, TDOM_KERNEL);
			LOG_EXTSVC_LEAVE(fncd, ercd);
			ソフトウェア割込みからリターン後のシステム状態が，
							この時点でのシステム状態になるよう準備する
		}
		else {
			（少なくとも）カーネル管理の割込みを禁止した状態にする
			if (p_runtsk->svclevel == UINT8_MAX) {
				ercd = E_SYS;
				ソフトウェア割込みからリターン後のシステム状態が，
						ソフトウェア割込み前のシステム状態になるよう準備する
			}
			else if (システムスタック領域の残りサイズ < p_svcinib->stksz) {
				ercd = E_NOMEM;
				ソフトウェア割込みからリターン後のシステム状態が，
						ソフトウェア割込み前のシステム状態になるよう準備する
			}
			else {
				if (rundom == TACP_KERNEL) {
					cdmid = TDOM_KERNEL;
				}
				else {
					rundom = TACP_KERNEL;
					cdmid = p_runtsk->p_tinib->domid;
				}
				p_runtsk->svclevel++;
				ソフトウェア割込み前のシステム状態に戻す
				LOG_EXTSVC_ENTER(fncd, パラメータリスト, cdmid);
				ercd = (*(p_svcinib->extsvc))(パラメータリスト, cdmid);
				LOG_EXTSVC_LEAVE(fncd, ercd);
				ソフトウェア割込みからリターン後のシステム状態が，
							この時点でのシステム状態になるよう準備する
				（少なくとも）カーネル管理の割込みを禁止した状態にする
				if (--p_runtsk->svclevel == 0U) {
					rundom = p_runtsk->p_dominib->domptn;
				}
			}
		}
	}

  error_exit:
	if (非特権モードからの呼び出し) {
		スタックを実行状態のタスクのユーザスタックに戻す
	}
	return(ercd);
}
----------------------------------------

6.8 システム周期オーバラン例外

システム周期の終了時刻にアイドルウィンドウを実行していなかった場合，カー
ネルは，システム周期オーバラン例外と呼ばれるエミュレートされたCPU例外
を発生させる［NGKI0596］．なお，システム周期オーバラン例外は，カーネル
管理外のCPU例外である［NGKI0603］．

ターゲット依存部では，システム周期オーバラン例外を発生させるための関数
と，発生した場合にCPU例外ハンドラを呼び出す処理を行う必要がある．また，
CPU例外ハンドラを定義しなかった場合に実行されるデフォルトのCPU例外ハン
ドラを修正し，システム周期オーバラン例外が発生した場合には，警告メッセー
ジをシステムログに出力して，そのまま実行を継続するようにする．

また，システム周期オーバラン例外のCPU例外ハンドラ番号を，カーネルAPIの
ターゲット依存部（target_kernel.hまたはそこからインクルードされるファ
イル）で，EXCNO_SCYCOVRにマクロ定義しておくことを推奨する（統合仕様書
には規定がない）．

(6-8-1) void raise_scycovr_exception(void)

システム周期オーバラン例外を発生させる関数．

6.9 スタートアップモジュール

HRP3カーネルでは，bssセクションとdataセクションがメモリ保護のために複
数にメモリ領域に分割される．そこで，カーネルのスタートアップモジュール
において，bssセクションとdataセクションの初期化を行う処理は，ターゲッ
ト非依存部で用意しているinitialize_sections関数（スタートアップモジュー
ルから呼び出す場合は，_kernel_initialize_sectionsとする必要がある）を
呼び出すことで行う．

6.10 カーネル実装に関するその他の定義

6.10.1 ターゲット依存のオブジェクト属性

(6-10-1-1) TARGET_REGATR（オプション）	ターゲット定義のメモリリージョン属性
(6-10-1-2) TARGET_MEMATR（オプション）	ターゲット定義のメモリオブジェクト属性
(6-10-1-3) TARGET_ACCATR（オプション）	ターゲット定義のメモリオブジェクトアク
										セス属性
(6-10-1-4) TARGET_SVCATR（オプション）	ターゲット定義の拡張サービスコール属性

各オブジェクトの属性をターゲット定義で拡張する場合に，該当するオブジェ
クト属性を示す変数に，拡張で使用するビットの論理和を定義する．これによ
り，拡張で使用するビットが設定されている場合にエラーになるのを防ぐ．

なお，TOPPERS新世代カーネル統合仕様書では，拡張サービスコール属性をター
ゲット定義で拡張できる仕様とはなっていない．

6.10.2 メモリ管理に関する処理の変更

メモリ管理のための処理は，ターゲットプロセッサが持つメモリ保護機能によっ
ては，様々な最適化の余地があることから，ターゲット依存に処理を変更でき
るようにしている．

(6-10-2-1) OMIT_STANDARD_MEMINIB（オプション）

メモリオブジェクト初期化ブロックをデータ型や生成方法を変更したい場合に，
このマクロを定義する．このマクロを定義すると，メモリオブジェクト初期化
ブロックのデータ型の定義，search_meminib関数，コンフィギュレータによる
メモリオブジェクト初期化ブロックの生成処理をターゲット依存部で用意しな
ければならない．また，メモリオブジェクト初期化ブロックの構造を大きく変
えた場合には，probe_mem_write，probe_mem_read，probe_memoryを変更する
必要がある．

(6-10-2-2) OMIT_PROBE_MEM_WRITE（オプション）
(6-10-2-3) OMIT_PROBE_MEM_READ（オプション）
(6-10-2-4) OMIT_PROBE_MEMORY（オプション）

probe_mem_write，probe_mem_read，probe_mememoryを変更したい場合には，
それらに対応するマクロを定義し，それらに変わる定義をターゲット依存部で
用意する．

(6-10-2-5) OMIT_INITIALIZE_MEMORY（オプション）

initialize_memory（標準では何もしない）を変更したい場合には，このマク
ロを定義し，それに変わる定義をターゲット依存部で用意する．

(6-10-2-6) OMIT_INITIALIZE_SECTIONS（オプション）

initialize_sectionsを変更したい場合には，このマクロを定義し，それに変
わる定義をターゲット依存部で用意する．

(6-10-2-7) OMIT_STANDARD_DATASECINIB（オプション）
(6-10-2-8) OMIT_STANDARD_BSSSECINIB（オプション）

dataセクション初期化ブロック，bssセクション初期化ブロックが不要な場合
や，それらの生成方法を変更したい場合に，それらに対応するマクロを定義す
る．このマクロを定義して生成方法を変更する場合には，コンフィギュレータ
によるdataセクション初期化ブロック，bssセクション初期化ブロックの生成
処理をターゲット依存部で用意しなければならない．

(6-10-2-9) TARGET_MEMATR_SSTACK（オプション）

コンフィギュレータが割り付けるシステムスタック領域および非タスクコンテ
キスト用スタック領域のメモリオブジェクト属性．この定義は，ターゲット依
存部で使うためのもので，ターゲット非依存部では使用しない．

(6-10-2-10) TARGET_MEMATR_USTACK（オプション）

コンフィギュレータが割り付けるユーザスタック領域のメモリオブジェクト属
性．定義しない場合，TA_NOINITSECが使われる．

(6-10-2-11) TARGET_MEMATR_MPFAREA（オプション）

コンフィギュレータが割り付ける固定長メモリプール領域のメモリオブジェク
ト属性．定義しない場合，TA_NOINITSECが使われる．

(6-10-2-12) OMIT_PROBE_MEM_WRITE_DOMPTN（オプション）
(6-10-2-13) OMIT_PROBE_MEM_RW_DOMPTN（オプション）

動的生成機能拡張パッケージを使用する場合で，probe_mem_write_domptn，
probe_mem_rw_domptnを変更したい場合には，それらに対応するマクロを定義
し，それらに変わる定義をターゲット依存部で用意する．

(6-10-2-14) OMIT_VALID_MEMOBJ_DOM（オプション）
(6-10-2-15) OMIT_VALID_USTACK（オプション）

動的生成機能拡張パッケージを使用する場合で，valid_memobj_dom，
valid_ustackが必要ない場合には，それらに対応するマクロを定義する．これ
らのマクロは，CHECK_TARGET_USTACKの定義に使用することを想定している．
CHECK_TARGET_USTACKのデフォルトの定義を用いる場合には，valid_ustackが
必要で，valid_memobj_domは必要ない．

6.10.3 エラーチェック方法の指定

(6-10-3-1) TARGET_MIN_SSTKSZ（オプション）
(6-10-3-2) TARGET_MIN_USTKSZ（オプション）

ターゲット定義で，タスクのシステムスタックサイズおよびユーザスタックサ
イズの最小値を設定する場合には，これらの変数をそれぞれのスタックサイズ
の最小値に定義する．ASP3カーネルの場合のTARGET_MIN_STKSZは使用しない．

(6-10-3-3) CHECK_SSTKSZ_ALIGN（オプション）
(6-10-3-4) CHECK_USTKSZ_ALIGN（オプション）

システムスタックサイズおよびユーザスタックサイズがある値（アライン単位）
の倍数でなければならない場合に，これらの変数をアライン単位に定義する．
ASP3カーネルの場合のCHECK_STKSZ_ALIGNは使用しない．

(6-10-3-5) CHECK_SSTACK_ALIGN（オプション）
(6-10-3-6) CHECK_USTACK_ALIGN（オプション）

システムスタック領域およびユーザスタック領域の先頭番地がある値（アライ
ン単位）の倍数でなければならない場合に，これらの変数をアライン単位に定
義する．ASP3カーネルの場合のCHECK_STACK_ALIGNは使用しない．

(6-10-3-7) CHECK_SSTACK_NONNULL（オプション）
(6-10-3-8) CHECK_USTACK_NONNULL（オプション）

システムスタック領域およびユーザスタック領域の先頭番地がNULLでないかの
チェックを行う場合には，これらの変数を定義する．ASP3カーネルの場合の
CHECK_STACK_NONNULLは使用しない．

6.11 タイムウィンドウタイマドライバ

タイムウィンドウタイマドライバは，カーネルが時間パーティショニング機能
の実現に用いるためのタイムウィンドウタイマを抽象化するためのデバイスド
ライバである．

6.11.1 タイムウィンドウタイマドライバのファイル構成

タイムウィンドウタイマドライバは，高分解能タイマドライバと同じファイル
の中に記述しても，別のファイルを用意して記述してもよい．

具体的には，タイムウィンドウタイマドライバを組み込むためのシステムコン
フィギュレーションファイル（target_timer.cfgの中に記述してもよい）には，
タイムウィンドウタイマドライバを初期化するための初期化ルーチンの追加，
タイムウィンドウタイマドライバを終了させるための終了処理ルーチンの追加，
タイムウィンドウタイマ割込みのための割込みハンドラの定義（または，割込
みサービスルーチンの生成），タイムウィンドウタイマ割込みのための割込み
要求ラインの属性の設定の静的APIなどを含むことになる．

また，タイムウィンドウタイマドライバを呼び出すために必要な定義を含むヘッ
ダファイル（target_timer.hの中に記述してもよい）と，タイムウィンドウタ
イマドライバの実装を含むファイル（target_timer.cの中に記述してもよい）
を用意する．

タイムウィンドウタイマ割込みの割込み優先度は，HRP3カーネルの設計制約上，
最低優先度とすることを原則とする．

6.11.2 タイムウィンドウタイマの操作と割込み処理

(6-11-2-1) void target_twdtimer_initialize(intptr_t exinf)

タイムウィンドウタイマの初期化処理を行う．タイマの動作開始は行わない．

この関数は，target_timer.cfg中に記述する静的APIにより，初期化ルーチンと
してカーネルに登録する．そのため，関数名を変更しても差し支えない．

(6-11-2-2) void target_twdtimer_terminate(intptr_t exinf)

タイムウィンドウタイマを停止させ，タイムウィンドウタイマ割込みを発生し
ないようにする．

この関数は，target_timer.cfg中に記述する静的APIにより，終了処理ルーチ
ンとしてカーネルに登録する．そのため，関数名を変更しても差し支えない．

(6-11-2-3) void target_twdtimer_start(PRCTIM twdtim)

タイムウィンドウタイマを，twdtimで指定した時間が経過したら割込みが発生
するように設定し，動作開始する．twdtimが0の場合は，できる限り早くタイ
ムウィンドウタイマ割込みを発生させる．twdtimの単位はマイクロ秒とする．

(6-11-2-4) PRCTIM target_twdtimer_stop(void)

タイムウィンドウタイマを停止し，タイマの残り時間（割込み発生までの時間）
を返す．残り時間がなくなっていた場合には，0を返す．また，タイムウィン
ドウタイマからの割込み要求をクリアする（クリアしないと不要な割込みが発
生するが，クリアすることは必須ではない）．

(6-11-2-5) PRCTIM target_twdtimer_get_current(void)

タイムウィンドウタイマの残り時間（割込み発生までの時間）を読み出す．残
り時間がなくなっていた場合には，0を返す．タイムウィンドウタイマからの
割込みはクリアしない．

(6-11-2-6) void target_twdtimer_handler(void)
    または void target_twdtimer_isr(intptr_t exinf)

タイムウィンドウタイマ割込みにより起動される割込み処理プログラム．割込
みハンドラとして実現する場合にはtarget_twdtimer_handler，割込みサービ
スルーチンとして実現する場合にはtarget_twdtimer_isrの名称とする．ター
ゲット非依存部のtwd_switchを呼び出す．

target_twdtimer_handlerは，標準的には次のように定義する．

----------------------------------------
void
target_twdtimer_handler(void)
{
	タイムウィンドウタイマ割込み要求のクリア（必要なら）
	twd_switch();					/* タイムウィンドウ切換え処理 */
}
----------------------------------------

この関数は，target_timer.cfg中に記述する静的APIにより，割込みハンドラ
または割込みサービスルーチンとしてカーネルに登録する．そのため，関数名
を変更しても差し支えない．

6.12 カーネル実装のコンフィギュレーションファイル

カーネル実装のコンフィギュレーションファイル（target_kernel.cfg）に，
ターゲットシステムのメモリ構成を定義するための静的APIを含める．具体的
には，ターゲットシステムのメモリ構成を定義するための静的APIを記述した
ファイル（target_mem.cfg）を用意し，target_kernel.cfgからインクルード
するようにする．

target_mem.cfgには，次のような静的APIを含める．

・ターゲットシステムのメモリリージョンの定義（自動メモリ配置の場合）
・標準メモリリージョンの定義（自動メモリ配置の場合）
・周辺デバイス領域の登録
・ベクタテーブルなどの配置


７．コンフィギュレータ設定ファイルのターゲット依存部

HRP3カーネルのコンフィギュレータ設定ファイルは，ASP3カーネルのものに対
して，大幅な拡張を行っている．以下では，ASP3カーネルと異なる点を中心に
説明する．

7.1 設定ファイルとターゲット依存部の位置付け

HRP3カーネルのコンフィギュレータの設定ファイルには，以下の6つがある．

(a) 静的APIテーブル

静的APIの一覧と，各静的APIのパラメータに関する情報を記述したファイル．
ASP3カーネルと同様，ターゲット非依存部で用意している（自動メモリ配置用：
kernel/kernel_api.def，手動メモリ配置用：kernel/kernel_api_mml.def）．

(b) 値取得シンボルテーブル

コンフィギュレータのパス1において，パラメータ計算用C言語ファイルに出力
し，値を求めたいシンボル（一般には式）を記述するためのファイル．

ASP3カーネルと同様，ターゲット非依存部では，ターゲットに依存せずに必要
となるシンボルを記述したファイルを用意しており（kernel/kernel_sym.def），
ターゲットに依存して必要となるシンボルがある場合には，ターゲット依存部
の値取得シンボルテーブル（標準的には，target_sym.def）を用意して，その
中に記述する．

(c) パス2の生成スクリプト

コンフィギュレータのパス2は，生成スクリプトにより，自動メモリ配置の場
合には，カーネルの構成・初期化ファイル（kernel_cfg.c），構成・初期化ヘッ
ダファイル（kernel_cfg.h）に加えて，仮のメモリ構成・初期化ファイル
（kernel_mem2.c），仮のリンカスクリプト（cfg2_out.ld）などを生成する．

また，手動メモリ配置の場合には，カーネルの構成・初期化ファイル
（kernel_cfg.c），構成・初期化ヘッダファイル（kernel_cfg.h）に加えて，
メモリ構成・初期化ファイル（kernel_mem.c）などを生成する．

ターゲット依存部ディレクトリに置かれたtarget_kernel.trbは，必要な変数
や関数を定義した後，ターゲット非依存部（kernel/kernel.trb）をインクルー
ドする．kernel.trbでは，カーネルのターゲット非依存部で使用する変数定義
等を生成する．

自動メモリ配置の場合には，kernel.trbのインクルードの後，kernel_mem2.c
に，メモリ保護設定のためのターゲット依存の情報（仮の情報）を生成する．
また，cfg2_out.ldを生成する．cfg2_out.ldの生成は，GNU開発環境において
は，必要な変数や関数を定義した後，そのための生成スクリプト
（arch/gcc/ldscript.trb）をインクルードすることで行う．

手動メモリ配置の場合には，kernel.trbのインクルードの後，kernel_mem.cに，
メモリ保護設定のためのターゲット依存の情報を生成する．

target_kernel.trbから，開発環境依存部／プロセッサコア依存部／チップ依
存部を切り分けてもよい（ldscript.trbを使用した場合，cfg2_out.ldの生成
を開発環境依存部に切り分けたことになる）．

(d) パス3の生成スクリプト（自動メモリ配置用，オプション）

自動メモリ配置におけるコンフィギュレータのパス3は，生成スクリプトによ
り，各種のテーブルのサイズを適正化や，メモリ保護単位のアラインメント／
配置アドレスの決定を行うためのパスで，用いるかどうかはターゲット依存で
ある．用いる場合には，仮のメモリ構成・初期化ファイル（kernel_mem3.c），
仮のリンカスクリプト（cfg3_out.ld）などを生成する．

パス3を使用する場合，ターゲット依存部ディレクトリに置かれた
target_opt.trbは，必要な変数や関数を定義した後，ターゲット非依存部
（kernel/kernel_opt.trb）をインクルードする．kernel_opt.trbでは，ター
ゲット非依存部で使用する各種のテーブルのサイズを適正化と，仮のメモリ構
成・初期化情報の生成を行う．kernel_opt.trbのインクルードの後，
kernel_mem3.cに，メモリ保護設定のためのターゲット依存の情報（仮の情報）
を生成する．また，cfg3_out.ldを生成する．

target_opt.trbから，開発環境依存部／プロセッサコア依存部／チップ依存部
を切り分けてもよい．

(e) パス4の生成スクリプト（自動メモリ配置用）

自動メモリ配置におけるコンフィギュレータのパス4は，生成スクリプトによ
り，メモリ構成・初期化ファイル（kernel_mem.c），リンカスクリプト
（ldscript.ld）などを生成する．

ターゲット依存部ディレクトリに置かれたtarget_mem.trbは，必要な変数や関
数を定義した後，ターゲット非依存部（kernel/kernel_mem.trb）をインクルー
ドする．kernel_mem.trbでは，ターゲット非依存部で使用するメモリ構成・初
期化情報の生成を行う．kernel_mem.trbのインクルードの後，kernel_mem.cに，
メモリ保護設定のためのターゲット依存の情報を生成する．また，
ldscript.ldを生成する．

最後に，チェックパスの生成スクリプト（target_check.trb）をインクルード
する．

target_mem.trbから，開発環境依存部／プロセッサコア依存部／チップ依存部
を切り分けてもよい．

(f) チェックパスの生成スクリプト

コンフィギュレータのチェックパスは，自動メモリ配置の場合はパス4で，手
動メモリ配置の場合はパス3で実行される処理で，生成スクリプトにより，静
的APIの一般定数式パラメータのチェックを行う．

ターゲット依存部ディレクトリに置かれたtarget_check.trbは，必要な変数や
関数を定義した後，ターゲット非依存部（kernel/kernel_check.trb）をイン
クルードする．kernel_check.trbでは，カーネルのターゲット非依存部で初期
化ブロックに出力した一般定数式パラメータのチェックを行う．
kernel_check.trbのインクルードの後，ターゲットに依存するチェックを行う．

target_check.trbから，開発環境依存部／プロセッサコア依存部／チップ依存
部を切り分けてもよい．

なお，コンフィギュレータの設定ファイルの記述方法については，「TOPPERS第
3世代カーネル向け Ruby版コンフィギュレータ ユーザーズマニュアル」を参照
すること．

7.2 パス2の生成スクリプトのターゲット依存部

この節では，パス2の生成スクリプトのターゲット依存部を記述する上で必要
な事項について説明する．

7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数

target_kernel.trbからkernel.trbをインクルードする前に，次の変数および
関数を定義しておかなければならない．なお，リストは，Rubyでは配列で実現
する．

(7-2-1-1) $INTNO_VALID
(7-2-1-2) $INHNO_VALID
(7-2-1-3) $EXCNO_VALID
(7-2-1-4) $INTNO_CREISR_VALID（オプション）
(7-2-1-5) $INHNO_CREISR_VALID（オプション）
(7-2-1-6) $INTPRI_CFGINT_VALID（オプション）
(7-2-1-7) $INTNO_FIX_KERNEL（オプション）
(7-2-1-8) $INHNO_FIX_KERNEL（オプション）
(7-2-1-9) $INHNO_FIX_NONKERNEL（オプション）
(7-2-1-10) $INHNO_FIX_NONKERNEL（オプション）
(7-2-1-11) GenerateTskinictxb（オプション）

これらの変数および関数については，ASP3カーネルと同様である．

(7-2-1-12) PrepareDominictxb(genFile)（オプション）

各保護ドメインのDOMINICTXBの初期化記述で，外部シンボルを参照する場合に，
そのextern宣言を生成するための関数PrepareDominictxbを定義する．
PrepareDominictxbには，extern宣言の生成先のファイルがパラメータとして
渡される．

USE_LATERPASS_DOMINIBをマクロ定義した場合には，パス2で生成される
DOMINICTXBは仮のものであるため，PrepareDominictxb，$kernelDominictxb，
GenerateDominictxbは，仮の情報を生成するものとなる．

(7-2-1-13) $kernelDominictxb（オプション）

カーネルドメインのDOMINICTXBの初期化記述を，この変数に定義する．
USE_DOMINICTXBをマクロ定義した場合，必ず定義しなければならない．

(7-2-1-14) GenerateDominictxb(key, params)（オプション）

ユーザドメインのDOMINICTXBの初期化記述を生成するための関数
GenerateDominictxbを定義する．GenerateDominictxbには，保護ドメインのID
番号（数値）とパラメータ情報（ハッシュ）が渡される．USE_DOMINICTXBをマ
クロ定義した場合には，必ず定義しなければならない．

(7-2-1-15) SecnameUserStack(tskid)

コンフィギュレータが割り付けるユーザスタック領域を配置するセクションの
名前を生成するための関数SecnameUserStackを定義する．SecnameUserStackに
は，タスクID（数値および名前）が渡される．

(7-2-1-16) AllocUserStack(stack, size, secname)

コンフィギュレータが割り付けるユーザスタック領域を確保する記述を生成す
るための関数AllocUserStackを定義する．AllocUserStackには，割り付けるユー
ザスタック領域の変数名，丸める前のサイズ，配置するセクションの名前が渡
されるので，ユーザスタック領域を確保するコードを生成し，大きい方に丸め
たサイズを表す文字列を返す．

(7-2-1-17) AllocDummyUserStack(stack, size, secname)（オプション）

レッドゾーン方式におけるダミースタック領域を確保する記述を生成するため
の関数AllocDummyUserStackを定義する．AllocDummyUserStackには，割り付け
るダミースタック領域の変数名，丸める前のサイズ，配置するセクションの名
前が渡されるので，ダミースタック領域を確保するコードを生成する．レッド
ゾーン方式を用いる場合には，必ず定義しなければならない．

(7-2-1-18) AllocSystemStack(stack, size)（オプション）

コンフィギュレータが割り付けるシステムスタック領域を確保する記述を生成
するための関数AllocSystemStackを定義する．AllocSystemStackには，割り付
けるシステムスタック領域の変数名と丸める前のサイズが渡されるので，シス
テムスタック領域を確保するコードを生成し，大きい方に丸めたサイズを表す
文字列を返す．システムスタック領域を確保する記述をデフォルトから変更し
たい場合のみ定義すればよい．なお，ASP3カーネルのAllocStackは使用しない．

(7-2-1-19) SecnameUserMempfix(mpfid)

コンフィギュレータが割り付ける固定長メモリプール領域を配置するセクショ
ンの名前を生成するための関数SecnameUserMempfixを定義する．
SecnameUserMempfixには，固定長メモリプールID（数値および名前）が渡され
る．

(7-2-1-20) AllocUserMempfix(mpf, blkcnt, blksz, secname)

コンフィギュレータが割り付ける固定長メモリプール領域を確保する記述を生
成するための関数AllocUserMempfixを定義する．AllocUserMempfixには，割り
付ける固定長メモリプール領域の変数名，ブロック数，丸める前のブロックサ
イズ，配置するセクションの名前が渡されるので，固定長メモリプール領域を
確保するコードを生成する．

(7-2-1-21) TargetCheckRegion(params)（オプション）

ATT_REGに関してターゲット依存のエラーチェックを行う必要がある場合には，
エラーチェックを行う関数TargetCheckRegionを定義する．TargetCheckRegion
には，ATT_REGのパラメータ情報（ハッシュ）が渡される．

(7-2-1-22) TargetCheckSection(params)（オプション）

ATT_SECに関してターゲット依存のエラーチェックを行う必要がある場合には，
エラーチェックを行う関数TargetCheckSectionを定義する．
TargetCheckSectionには，ATT_SECのパラメータ情報（ハッシュ）が渡される．

(7-2-1-23) TargetCheckMemory(params)（オプション）

ATT_MEM／ATT_PMAに関してターゲット依存のエラーチェックを行う必要がある
場合には，エラーチェックを行う関数TargetCheckMemoryを定義する．
TargetCheckMemoryには，ATT_MEM／ATT_PMAのパラメータ情報（ハッシュ）が
渡される．

(7-2-1-24) $START_OBJS（オプション）
(7-2-1-25) $END_OBJS（オプション）

ロードモジュールの先頭と最後にリンクすべきオブジェクトモジュール名のリ
ストを，それぞれ，$START_OBJSと$END_OBJSに定義する．ここにリストアップ
したオブジェクトモジュール名は，カーネルドメインの先頭および末尾に
ATT_MODしたのと同等に扱われる．Makefileのターゲット依存部に定義する
START_OBJSとEND_OBJSと同じ内容とするのが基本である．

(7-2-1-26) $TARGET_LIBS（オプション）

コンパイラが必ず用いるライブラリのリストを定義する．ここにリストアップ
したオブジェクトモジュール名は，無所属の末尾にATT_MODしたのと同等に扱
われる．

(7-2-1-27) $defaultSections

標準のセクションに関する情報を，$defaultSectionsに定義する．この変数に
は，標準セクションの名前，標準メモリリージョンの中のどれに配置するか，
標準メモリオブジェクト属性をハッシュで表現し，そのリストを定義する．
ショートデータ領域を持たない場合の典型的な定義の例は，次の通り．

----------------------------------------
$defaultSections = [
  { SECNAME: ".text",   MEMREG: :stdrom, MEMATR: $mematrTextSec },
  { SECNAME: ".rodata", MEMREG: :stdrom, MEMATR: $mematrRodataSec },
  { SECNAME: ".data",   MEMREG: :stdram, MEMATR: $mematrDataSec },
  { SECNAME: ".bss",    MEMREG: :stdram, MEMATR: $mematrBssSec },
  { SECNAME: ".noinit", MEMREG: :stdram, MEMATR: $mematrNoinitSec }
]
----------------------------------------

ショートデータ領域を持つ場合には，次のようになる．ここで，
$mematrShortRodataSec，$mematrShortDataSec，$mematrShortBssSec，
$mematrShortNoinitSecは，ターゲット依存部で定義する必要がある．
  
----------------------------------------
$defaultSections = [
  { SECNAME: ".text",    MEMREG: :stdrom,  MEMATR: $mematrTextSec },
  { SECNAME: ".rodata",  MEMREG: :stdrom,  MEMATR: $mematrRodataSec },
  { SECNAME: ".data",    MEMREG: :stdram,  MEMATR: $mematrDataSec },
  { SECNAME: ".bss",     MEMREG: :stdram,  MEMATR: $mematrBssSec },
  { SECNAME: ".noinit",  MEMREG: :stdram,  MEMATR: $mematrNoinitSec }
  { SECNAME: ".srodata", MEMREG: :stdsrom, MEMATR: $mematrShortRodataSec },
  { SECNAME: ".sdata",   MEMREG: :stdsram, MEMATR: $mematrShortDataSec },
  { SECNAME: ".sbss",    MEMREG: :stdsram, MEMATR: $mematrShortBssSec },
  { SECNAME: ".snoinit", MEMREG: :stdsram, MEMATR: $mematrShortNoinitSec }
]
----------------------------------------

(7-2-1-28) $targetStandardSecnameList（オプション）

ターゲットに依存して，ATT_SECで登録できないセクション名を追加する必要
がある場合には，セクション名のリストをこの変数に定義する．GNU開発環境
では，COMMONがこれに該当するため，以下の定義を行う．

----------------------------------------
$targetStandardSecnameList = [ "COMMON" ]
----------------------------------------

(7-2-1-29) TargetMemoryObject()（オプション）

ターゲットに依存して，メモリオブジェクトを登録する必要がある場合には，
メモリオブジェクトを登録する関数TargetMemoryObjectを定義する．ARMター
ゲット依存部では，MMUのページテーブルを配置するためのセクションを登録
している．

(7-2-1-30) TargetCalcMeminibSize(size)（オプション）

ターゲットに依存して，メモリオブジェクト初期化ブロックのサイズを変更し
たい場合に，変更後のサイズを返す関数TargetCalcMeminibSizeを定義する．
TargetCalcMeminibSizeには，変更前のサイズが渡される．リンカによっては，
コンフィギュレータが想定していない隙間が生じ，メモリオブジェクト初期化
ブロックのサイズが不足する場合がある．そのような場合には，この関数を用
いてメモリ初期化ブロックのサイズを大きくして回避する必要がある．

7.2.2 ターゲット非依存部で定義される変数と関数

kernel.trbの中では次の変数／関数が定義されるため，kernel.trbのインクルー
ドの後，target_kernel.trbの中でこれらを参照／使用することができる．

(7-2-2-1) $toIntnoVal[inhnoVal]
(7-2-2-2) $toInhnoVal[intnoVal]

これらの変数については，ASP3カーネルと同様である．

(7-2-2-3) GenerateMemProt()

メモリ保護単位に関する情報を生成するための関数．主にMMUを持つターゲッ
ト向けに，メモリ保護設定のためのターゲット依存の情報を生成するのに役立
つ情報を$memProtに生成する．手動メモリ配置の場合には，必要に応じて，パ
ス2の生成スクリプトのターゲット依存部からこの関数を呼び出す（自動メモ
リ配置の場合にはパス4）．

7.2.3 リンカスクリプトの生成スクリプトをインクルードする前に定義すべき
	  変数と関数

GNU開発環境向けにリンカスクリプトを生成するための生成スクリプトを使用
する場合には，target_kernel.trbからldscript.trbをインクルードする前に，
次の変数および関数を定義しておかなければならない．

(7-2-3-1) $TARGET_SEC_ALIGN_STR
(7-2-3-2) $TARGET_MP_ALIGN_STR

セクションをアラインさせる際のアライン単位の文字列を
$TARGET_SEC_ALIGN_STRに，メモリ保護単位をアラインさせる際のアライン単
位（通常はページサイズに一致する）の文字列を$TARGET_PAGE_SIZE_STRに定
義する．

(7-2-3-3) GenerateOutput()（オプション）

リンカスクリプトの先頭のOUTPUT記述を生成する関数GenerateOutputを定義す
る．GenerateOutputを定義しない場合，OUTPUT記述を生成しない．

(7-2-3-4) GenerateProvide()（オプション）

リンカスクリプト中にPROVIDE記述を生成する関数GenerateProvideを定義する．
GenerateProvideを定義しない場合，PROVIDE記述を生成しない．

(7-2-3-5) SectionDescription(secname)

セクション名から，リンカスクリプトの出力するセクション記述を生成するた
めの関数SectionDescriptionを定義する．SectionDescriptionの典型的な定義
は次のようになる．

----------------------------------------
def SectionDescription(secname)
  case secname
  when ".text"
    return(".text .text.*")
  when ".rodata"
    return(".rodata .rodata.*")
  when ".data"
    return(".data .data.*")
  when ".bss"
    return(".bss .bss.* COMMON")
  else
    return(secname)
  end
end
----------------------------------------

(7-2-3-6) HookEndLabel(regname)（オプション）

保護ドメイン共通の標準ROMリージョンに出力される標準共有リードオンリー
領域の最後に，言語依存（具体的にはC++用）のセクションを出力する必要が
ある場合には，セクション出力記述を生成する関数HookEndLabelを定義する．
HookEndLabelには，出力先のメモリリージョン名が渡される．

7.3 パス3の生成スクリプトのターゲット依存部（自動メモリ配置用，オプション）

target_opt.trbからkernel_opt.trbをインクルードする前に，必要に応じて，
次の変数および関数を定義しておかなければならない．

(7-3-1) $OPTIMIZE_MEMINIB（オプション）

ターゲット非依存部において，メモリオブジェクト初期化ブロックのサイズの
適正化を行う場合には，この変数をtrueに定義する．

(7-3-2) $OPTIMIZE_DATASEC_LIST（オプション）

ターゲット非依存部において，dataセクション初期化ブロックのサイズの適正
化を行う場合には，この変数をtrueに定義する．

(7-3-3) $OPTIMIZE_BSSSEC_LIST（オプション）

ターゲット非依存部において，bssセクション初期化ブロックのサイズの適正
化を行う場合には，この変数をtrueに定義する．

(7-3-4) PrepareDominictxb(genFile)（オプション）
(7-3-5) $kernelDominictxb（オプション）
(7-3-6) GenerateDominictxb(key, params)（オプション）

USE_LATERPASS_DOMINIBをマクロ定義した場合，パス2と同様に，必要に応じて
これらの変数および関数を定義する．パス3で生成されるDOMINICTXBは仮のも
のであるため，PrepareDominictxb，$kernelDominictxb，GenerateDominictxb
は，仮の情報を生成するものとなる．

7.4 パス4の生成スクリプトのターゲット依存部（自動メモリ配置用）

7.4.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数

target_mem.trbからkernel_mem.trbをインクルードする前に，必要に応じて，
次の変数および関数を定義しておかなければならない．

(7-4-1-1) PrepareDominictxb(genFile)（オプション）
(7-4-1-2) $kernelDominictxb（オプション）
(7-4-1-3) GenerateDominictxb(key, params)（オプション）

USE_LATERPASS_DOMINIBをマクロ定義した場合，パス2と同様に，必要に応じて
これらの変数および関数を定義する．

7.4.2 ターゲット非依存部で定義される変数と関数

kernel_mem.trbの中では次の関数が定義されるため，kernel_mem.trbのインク
ルードの後，target_mem.trbの中でこれらを使用することができる．

(7-4-2-1) GenerateMemProt()

メモリ保護単位に関する情報を生成するための関数．主にMMUを持つターゲッ
ト向けに，メモリ保護設定のためのターゲット依存の情報を生成するのに役立
つ情報を$memProtに生成する．自動メモリ配置の場合には，必要に応じて，パ
ス4の生成スクリプトのターゲット依存部からこの関数を呼び出す（手動メモ
リ配置の場合にはパス2）．

7.5 チェックパスの生成スクリプトのターゲット依存部

target_check.trbからkernel_check.trbをインクルードする前に，必要に応じ
て，次の変数および関数を定義しておかなければならない．

7.5.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数

(7-5-1-1) GetStackTskinictxb(key, params, tinib)（オプション）
(7-5-1-2) $lmaList（手動メモリ配置の場合，オプション）

これらの変数および関数については，ASP3カーネルと同様である．

7.5.2 ターゲット依存部で行うべきエラーチェック

ターゲット依存部で行うべきエラーチェックは，ASP3カーネルと同様である．
必要であれば，メモリ管理に関するエラーチェックを追加する（自動メモリ配
置の場合には，パス3やパス4で行うこともできる）．

7.6 cfg1_out.cのリンクに必要なスタブの定義ファイル

cfg1_out.cのリンクに必要なスタブの定義ファイル（target_cfg1_out.h）は，
ASP3カーネルと同様であるが，スタートアップモジュールから
initialize_sectionsを呼び出す場合には，initialize_sectionsのスタブの定
義の追加が必要になる．


８．システムサービス等のターゲット依存部

HRP3カーネルのシステムサービス等は，ASP3カーネルとほぼ同じものを使用し
ており，そのターゲット依存部も，ASP3カーネルとほぼ同じである．以下では，
ASP3カーネルと異なる点についてのみ説明する．

8.1 ターゲット依存部のコンポーネント記述ファイル

ターゲット依存部のコンポーネント記述ファイル（target.cdl）には，ASP3カー
ネルでの記述に加えて，以下の内容を記述する．また，セルの組み上げ記述に
ついては，rKernelDomainリージョンの囲みの中に入れるように修正する．

(8-1-1) 拡張サービスコールのスタックサイズのデフォルト

そのターゲットシステムにおける拡張サービスコールのスタックサイズのデフォ
ルト値を，下の例のように，DefaultExtsvcStackSizeに定義する．

----------------------------------------
const size_t DefaultExtsvcStackSize = 1024;
----------------------------------------

8.2 サンプルプログラムとテストプログラムのターゲット依存定義

サンプルプログラムおよびテストプログラムのためのターゲット依存定義ファ
イル（target_test.h）には，ASP3カーネルでの記述に加えて，以下の内容を
記述する．

(8-2-1) EXCNO_MACV_INST

プログラムの実行アクセスに伴うメモリ保護違反例外ハンドラのCPU例外ハン
ドラ番号をこのマクロに定義する．

(8-2-2) EXCNO_MACV_DATA

データの書込み／読出しアクセスに伴うメモリ保護違反例外ハンドラのCPU例
外ハンドラ番号をこのマクロに定義する．

(8-2-3) PREPARE_RETURN_MACV_INST（オプション）

プログラムの実行アクセスに伴うメモリ保護違反例外ハンドラからリターンす
る場合に，特殊な処理（例えば，戻り先番地の調整）が必要な場合には，この
マクロに定義する．

(8-2-4) PREPARE_RETURN_MACV_DATA（オプション）

データの書込み／読出しアクセスに伴うメモリ保護違反例外ハンドラからリター
ンする場合に，特殊な処理（例えば，戻り先番地の調整）が必要な場合には，
このマクロに定義する．


９．その他

ASP3カーネルのポーティングにあたってのその他の事項は，HRP3カーネルのポー
ティングにも適用される．以下では，ASP3カーネルと異なる点についてのみ説
明する．

9.1 その他に修正が必要な箇所

ASP3カーネルのターゲット依存部を元に，HRP3カーネルのターゲット依存部を
開発する場合，以上で説明した以外に，次の修正が必要になるのが一般的であ
る．

(9-1-1) システム略称.h

ページサイズなど，メモリ保護に必要な定義を追加する．

(9-1-2) target_sym.def

ページサイズなど，コンフィギュレータの生成スクリプトで新たに必要になっ
たシンボル等を追加する．

(9-1-3) target_offset.trb

アセンブリ言語で記述されるプログラムで新たに参照するようになったシンボ
ルを追加する．

(9-1-4) target_timer.cfg

静的APIをカーネルドメインの囲みの中に入れるように修正する．

(9-1-5) target_rename.def，target_rename.h，target_unrename.h

ターゲット依存部で新たに使用するようになったシンボルを追加する．

9.2 ドキュメント

ターゲット依存部のユーザーズマニュアルには，ASP3カーネルのものに対して，
次の記述内容の追加が必要である．

(3) ターゲット定義事項の規定

(3-7) メモリ保護機能に関する規定
	・自動メモリ配置，手動メモリ配置のサポートの有無
	・ATT_MOD，ATT_PMAのサポートの有無
	・メモリリージョンの先頭番地とサイズに対する制約
	・メモリオブジェクトの先頭番地とサイズに対する制約
	・ターゲット定義のメモリリージョン属性
	・ターゲット定義のメモリオブジェクト属性
	・メモリオブジェクト属性に関するターゲット依存の扱い
	・ATT_SEC，ATT_MOD，ATT_MEM／ATT_PMAに関するターゲット依存の制限
	・タスクのユーザスタック領域を，そのタスクが属する保護ドメイン全体
	　からアクセスできるものとするか
	・許可されていない書込みアクセスまたは読出しアクセス（実行アクセス
	　を含む）を行おうとした場合に起動されるCPU例外ハンドラ

(3-8) 時間パーティショニング機能に関する規定
	・システム周期オーバラン例外の例外ハンドラ番号
	・タイムウィンドウの長さに指定できる値の上限（TMAX_TWDTIMの値）

以上
